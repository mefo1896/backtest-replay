const chart = LightweightCharts.createChart(document.getElementById('chart'), {
  width: document.getElementById('chart').offsetWidth,
  height: 500,
  layout: {
    backgroundColor: '#ffffff',
    textColor: '#000',
  },
  grid: {
    vertLines: { color: '#eee' },
    horzLines: { color: '#eee' },
  },
});

const candleSeries = chart.addCandlestickSeries();
const emaFastSeries = chart.addLineSeries({ color: 'blue', lineWidth: 2 });
const emaSlowSeries = chart.addLineSeries({ color: 'red', lineWidth: 2 });

let cData = [];
let currentIndex = 50; // B·∫Øt ƒë·∫ßu hi·ªÉn th·ªã t·ª´ n·∫øn th·ª© 50
let replayInterval = null;

// H√†m t√≠nh EMA
function calculateEMA(data, period) {
  let k = 2 / (period + 1);
  let emaArray = [];
  let ema = data[0].close;

  data.forEach((d, i) => {
    if (i === 0) {
      emaArray.push(ema);
    } else {
      ema = d.close * k + ema * (1 - k);
      emaArray.push(ema);
    }
  });
  return emaArray;
}

// Backtest t·ª´ng b∆∞·ªõc
function updateChart(index) {
  if (index < 50) return; // Hi·ªÉn th·ªã √≠t nh·∫•t 50 n·∫øn ƒë·ªÉ t√≠nh EMA

  const partialData = cData.slice(0, index);
  const emaFast = calculateEMA(partialData, 9);
  const emaSlow = calculateEMA(partialData, 21);

  candleSeries.setData(partialData);
  emaFastSeries.setData(partialData.map((d, i) => ({
    time: d.time,
    value: emaFast[i],
  })));
  emaSlowSeries.setData(partialData.map((d, i) => ({
    time: d.time,
    value: emaSlow[i],
  })));

  // T√¨m t√≠n hi·ªáu Buy/Sell
  let signals = [];
  for (let i = 1; i < partialData.length; i++) {
    if (emaFast[i - 1] < emaSlow[i - 1] && emaFast[i] > emaSlow[i]) {
      signals.push({ time: partialData[i].time, type: 'buy', price: partialData[i].close });
    } else if (emaFast[i - 1] > emaSlow[i - 1] && emaFast[i] < emaSlow[i]) {
      signals.push({ time: partialData[i].time, type: 'sell', price: partialData[i].close });
    }
  }

  // V·∫Ω t√≠n hi·ªáu
  signals.forEach(signal => {
    chart.addShape({
      time: signal.time,
      position: signal.type === 'buy' ? 'belowBar' : 'aboveBar',
      shape: signal.type === 'buy' ? 'arrowUp' : 'arrowDown',
      color: signal.type === 'buy' ? 'green' : 'red',
      text: signal.type.toUpperCase(),
    });
  });

  // C·∫≠p nh·∫≠t k·∫øt qu·∫£
  let balance = 1000;
  let position = null;
  let entryPrice = 0;
  let win = 0;
  let loss = 0;

  signals.forEach(signal => {
    if (signal.type === 'buy' && position === null) {
      entryPrice = signal.price;
      position = 'long';
    } else if (signal.type === 'sell' && position === 'long') {
      let profit = (signal.price - entryPrice) / entryPrice * 100;
      balance *= (1 + profit / 100);
      if (profit > 0) win++;
      else loss++;
      position = null;
    }
  });

  let totalTrades = win + loss;
  let winrate = totalTrades ? (win / totalTrades * 100).toFixed(2) : 0;
  document.getElementById('stats').innerHTML = `
    üìà T·ªïng l·ªánh: ${totalTrades}<br>
    ‚úÖ Th·∫Øng: ${win}<br>
    ‚ùå Thua: ${loss}<br>
    üèÜ Winrate: ${winrate}%<br>
    üí∞ Balance: $${balance.toFixed(2)}
  `;
}

// Replay ƒëi·ªÅu khi·ªÉn
document.getElementById('backward').onclick = () => {
  if (currentIndex > 50) {
    currentIndex--;
    updateChart(currentIndex);
  }
};

document.getElementById('forward').onclick = () => {
  if (currentIndex < cData.length) {
    currentIndex++;
    updateChart(currentIndex);
  }
};

document.getElementById('play').onclick = () => {
  if (replayInterval) clearInterval(replayInterval);
  replayInterval = setInterval(() => {
    if (currentIndex < cData.length) {
      currentIndex++;
      updateChart(currentIndex);
    } else {
      clearInterval(replayInterval);
    }
  }, 500); // t·ªëc ƒë·ªô replay (ms)
};

document.getElementById('pause').onclick = () => {
  if (replayInterval) clearInterval(replayInterval);
};

// Fetch d·ªØ li·ªáu
fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=5m&limit=500')
  .then(res => res.json())
  .then(data => {
    cData = data.map(d => ({
      time: d[0] / 1000,
      open: parseFloat(d[1]),
      high: parseFloat(d[2]),
      low: parseFloat(d[3]),
      close: parseFloat(d[4]),
    }));
    updateChart(currentIndex);
  });
